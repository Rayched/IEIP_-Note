
#### 알고리즘의 정의

- 어떠한 문제를 해결하기 위해서 정해진 일련의 절차, 방법 <br/>
	공식화한 형태로 표현한 기법
- 알고리즘은 `자연어`, `순서도`, *`의사 코드`*, `프로그래밍 언어`를 이용해서 표현하며 <br/>
	프로그래밍 언어가 아니더라도 알고리즘의 표현이 가능하다.
- 아래의 표는 알고리즘을 표현할 때 지켜야 할 규칙 같은 거다.

| 규칙     | 설명                        |
| ------ | ------------------------- |
| Input  | 외부로부터 입력되는 자료 0개 이상       |
| Output | 출력되는 결과 1개 이상             |
| 명확성    | 각 명령어의 의미가 명확해야한다.        |
| 유한성    | 정해진 단계를 지나면 종료            |
| 유효성    | 모든 명령은 실행이 가능한 연산들이어야 한다. |

```
의사 코드 Pseudo Code (슈도 코드)

- 프로그램을 작성할 때, 각 Module이 작동하는 논리를 표현하기 위한 언어
- 일반적인 언어로 코드를 흉내내어 알고리즘을 써놓은 코드
```

---

#### 알고리즘 기법

- 알고리즘을 설계할 때 사용하는 기법으로는 <br/>
	`분할과 정복`, `동적 계획법`, `탐욕법`, `백트래킹` 기법이 존재한다.

| 설계 기법                           | 설명                                                                     |
| ------------------------------- | ---------------------------------------------------------------------- |
| 분할과 정복 <br/>Divide and Conquer  | 문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 <br/>다시 병합하여 문제의 답을 얻는 알고리즘 기법            |
| 동적 계획법 <br/>Dynamic Programming | 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고 <br/>과거에 구한 해를 활용하는 방식의 알고리즘    |
| 탐욕법 <br/>Greedy                 | 결정을 해야할 때마다 그 순간에 가장 좋다고 생각되는 것을 <br/>해답으로 선택함으로써 최종 해답에 도달하는 방식의 알고리즘 |
| 백트래킹 <br/>Backtracking          | 어떤 노드의 유망성 점검 후, 유망하지 않으면 해당 노드의 부모로 복귀 <br/>다른 자손 노드를 검색하는 알고리즘       |

- { '분' - '동' - '탐' - '백' } 암기
---

#### 시간 복잡도 Time Complexity

- 알고리즘 문제는 문제에 대한 해답을 찾는 것이 가장 중요하지만 <br/>
	그에 못지않게, "효율적인 방법으로 문제를 해결했는가"도 중요하다.
- 알고리즘을 구현할 때 효율적인 방법을 고민한다는 것은 `시간 복잡도`를 고민한다는 것이다.
- 여기서 `시간 복잡도`는 다음과 같다.

```
알고리즘의 시간 복잡도를 고민하는 것
=> "입력 값의 변화에 따라 연산을 실행할 때
    연산 횟수에 비해 시간이 얼마만큼 걸리는가."
```

- 효율적인 알고리즘 구현 == 입력 값이 커짐에 따라 증가하는 시간 비율 최소화한 알고리즘 구현
* 이러한 `시간 복잡도`는 Big-O 표기법을 사용해서 나타낸다.

---

#### Big-O 표기법

- 알고리즘의 효율성을 표기해주는 기법
- 알고리즘 최악의 실행 시간을 표기하는 기법, 제일 많이 사용하는 표기법
- 최소한 보장되는 성능을 표기하기 때문에, 가장 일반적으로 사용한다.

- 이 외에도 시간 복잡도를 표기하는 기법으로 <br/>
	`Big-Ω`, `Big-θ` 표기법이 존재한다.
	- `Big-Ω`: 알고리즘 **최상**의 실행 시간을 표기한다.
	- `Big-θ`: 알고리즘 **평균** 실행 시간을 표기한다.

| 복잡도        | 설명                                                                        | 대표 알고리즘                |
| ---------- | ------------------------------------------------------------------------- | ---------------------- |
| O(1)       | 상수형 복잡도 <br/>자료 크기 무관하게 항상 같은 속도로 작동 <br/>알고리즘 수행 시간이 입력 데이터 수와 관계없이 일정함. | Hash Function          |
| O(log n)   | log형 복잡도 <br/>문제를 해결하기 위한 단계의 수가 <br/>log n번 만큼의 수행 시간을 가진다.              | Binary Search          |
| O(n)       | 선형 복잡도 <br/>입려 자료를 차례로 하나씩 모두 처리 <br/>수행 시간이 자료 크기와 직접적 관계로 정비례           | Sequential Search      |
| O(n log n) | 선형 로그형 복잡도 <br/>문제를 해결하기 위한 단계의 수가 <br/>`n log n`번만큼의 수행 시간을 가진다.         | 퀵 정렬, 병합 정렬 <br/>힙 정렬  |
| O(n^2)     | 제곱형 주요 처리 루프 구조가 2중인 경우 <br/>n 크기 작을 때는 `n^2`가 `n log n`보다 빠를 수 있음        | 거품 정렬, 삽입 정렬<br/>선택 정렬 |

---

